# GPUによるパノラマ画像バッチマッチング高速化研究計画  
**著者:** 角田 想（Sumida Sou）  
**最終更新:** 2025-10-21  

---

## 1. 研究概要
本研究では、72枚の画像を結合して作成した横長のパノラマ画像と、ユーザーが撮影した単一画像との**特徴点マッチング処理の高速化**を目的とする。  
SIFT特徴量をHDF5形式で格納し、OpenCLによるGPU並列マッチングを実装した。  
さらに、将来的にはKLD（Kullback–Leibler Divergence）を用いて、**不要な特徴点を自動除去する前処理**を導入し、処理時間の削減を図る。

---

## 2. 背景と課題
- パノラマ画像は72枚の静止画像を横方向に結合したもので、横幅が非常に大きい。  
- 特徴点マッチングでは、ユーザー画像と全フレーム間での照合が必要となり、計算コストが高い。  
- CPU処理では数分を要するため、GPUを用いた並列処理による**リアルタイム応答性の向上**が求められる。  

---

## 3. 研究目的
- OpenCLを用いてGPU上でSIFT特徴点マッチングを並列実行する。  
- 特徴点データをHDF5ファイルで効率的に管理し、I/Oボトルネックを低減する。  
- 段階的探索（粗スキャン → 詳細スキャン）による検索空間の削減を実現する。  
- 将来的にはKLDベースの特徴点フィルタリングにより、**マッチングに不要な領域を事前除去**する。

---

## 4. システム構成概要
### 4.1 データ構造
- **入力:**  
  - パノラマ画像（72フレーム結合済み）  
  - ユーザー撮影画像（例: `lane1_tigenabe.jpg`）
- **HDF5構成:**  
  ```
  panorama_sift_all_sections.h5
  ├── upper/
  │   ├── frame_1, frame_2, ...
  ├── middle/
  ├── lower/
  ├── panorama_image_small (圧縮サムネイル)
  └── attrs: panorama_width, panorama_height, total_frames, ...
  ```

### 4.2 GPU処理概要
- **OpenCLカーネル**: `sift_matcher.cl`  
- **カーネル関数**: `compute_min2_distances_unrolled`  
  - 特徴点同士の距離をfloat4ベクトル化で計算。  
  - ローカルメモリを活用し、メモリアクセスを最適化。  
  - 各フレーム内で最近傍2点の距離を求め、Lowe比判定で有効マッチを抽出。  

---

## 5. プログラム構成

### 5.1 `panorama_vertical_hdf5_batch_matching.py`
パノラマ画像を縦方向に3分割（上部・中央・下部）し、  
各セクションごとにバッチマッチングを行う実験用プログラム。

#### 主な関数
| 関数名 | 概要 |
|--------|------|
| `load_batch_hdf5_descriptors_with_section()` | 指定セクションの特徴点をHDF5から一括読み込み |
| `run_gpu_batch_matching()` | 全フレームの特徴点を結合し、GPUで一括マッチング実行 |
| `init_opencl()` | OpenCL環境とカーネルの初期化 |
| `create_histogram()` | 各フレームのマッチ数をヒストグラムとして可視化 |
| `main()` | 上部・中央・下部セクションの選択的バッチマッチング処理 |

#### 処理の流れ
1. ユーザー画像をSIFTで特徴点抽出  
2. 指定セクションのHDF5データを読み込み  
3. 第1段階（粗スキャン）で広範囲を3フレーム間隔で検索  
4. 第2段階（詳細スキャン）で近傍フレームを精査  
5. GPUマッチング結果を可視化・ヒストグラム化  

---

### 5.2 `main.py`
パノラマ画像全体（分割なし）に対してGPUマッチングを実施する統合版。  
各フレームをセクション横断的に結合し、全域を一括処理する。

#### 主な処理
1. HDF5内の全セクションを走査し、各フレームごとに記述子を結合。  
2. ユーザー画像のSIFT特徴量を抽出。  
3. `run_gpu_batch_matching()` により全フレームをGPU処理。  
4. 最もマッチ数が多いフレームを検出し、パノラマ上にハイライト表示。  
5. 結果画像とマッチ数ヒストグラムを出力。  

---

## 6. 数式（マッチング評価）

GPU内で使用する距離計算およびLowe比判定は次式に基づく：

$$
D_{KL}(P_a || P_b) = \sum_x P_a(x) \log rac{P_a(x)}{P_b(x)}
$$

$$
\text{ratio test: } \frac{d_1^2}{d_2^2} < \text{threshold}^2 \quad (\text{通常 } 0.75^2)
$$

---

## 7. 想定成果と展望
- GPU最適化により、CPU比で**10倍以上の高速化**を達成。  
- HDF5による入出力効率化により、ロード時間を大幅短縮。  
- 今後、KLDベースの特徴点除去を導入し、  
  - 情報量の低い領域を事前スキップ  
  - マッチング不要部分を自動判定  
  によって、さらなる**リアルタイム性能向上**を目指す。

---

## 8. 使用技術
| 分類 | 技術 |
|------|------|
| 言語 | Python 3.10 |
| GPU計算 | OpenCL (Metal backend, macOS M2 Ultra) |
| 特徴抽出 | OpenCV SIFT |
| データ格納 | HDF5 (h5py) |
| 可視化 | Matplotlib |
| 並列化 | pyopencl, float4ベクトル演算 |

---

## 9. 出力例
- `gpu_sift_panorama_vertical_upper_hdf5_batch_match_result.jpg`  
  → 最良フレームを緑枠でハイライトした結果画像。  
- `gpu_sift_panorama_vertical_upper_hdf5_batch_match_histogram.png`  
  → フレームごとのマッチ数分布を表示したヒストグラム。

---

## 10. 今後の展望
- **KLDによる特徴点選別**
  - フレーム間の情報量変化をKLDで定量化し、  
    類似分布を持つ領域の特徴点を削除。
- **CNN特徴量との統合**
  - SIFTの局所特徴に加え、CNNによる高次元特徴で精度補完。
- **リアルタイム実装**
  - GPUマッチング＋KLD選別を統合し、現場環境でのナビゲーション応用を想定。

---

**キーワード:**  
GPU, OpenCL, HDF5, パノラマ画像, SIFT, KLD, 特徴点マッチング, 高速化


---

## 11. KLDを用いた特徴点選定による高速化手法

### 背景
パノラマ画像は72枚を横に結合して作成しており、全特徴点を用いたマッチング処理では計算コストが非常に大きい。  
このため、マッチング前に不要な特徴点を削減することが有効である。

### 提案手法
各フレーム（またはパノラマの分割領域）ごとに特徴点の分布を確率分布として表し、  
フレーム間の情報量の差を **KLD（Kullback–Leibler Divergence）** によって定量化する。

KLDは次式で定義される：

$$
D_{KL}(P_a || P_b) = \sum_x P_a(x) \log \frac{P_a(x)}{P_b(x)}
$$

ここで、$P_a(x)$ と $P_b(x)$ は隣接するフレームにおける特徴点の分布である。

### 手順
1. パノラマ画像をフレーム単位またはセクション単位に分割する。  
2. 各フレーム内の特徴点位置 $(x, y)$ をヒストグラム化し、確率分布 $P_i(x, y)$ を得る。  
3. 隣接する分布間で KLD を計算し、変化が小さい領域（情報量が低い領域）を特定する。  
4. 変化量が小さいフレームまたは特徴点群をマッチング対象から除外する。  
5. 残った「情報量の高い」フレームに対してのみ GPU マッチングを実行する。

### 効果
- 類似した景観や繰り返しパターンの領域を自動的にスキップできる。  
- マッチング処理に必要な特徴点数を削減し、GPU計算の実行時間を短縮できる。  
- 将来的には、KLDマップを事前に計算しておくことで、リアルタイム照合を可能にする。

### 実装案（`main.py` への統合）
- `main.py` 実行前に、HDF5内の各フレーム特徴点を解析し、KLDスコアを計算して保存する。  
- `run_gpu_batch_matching()` 呼び出し前に、KLDスコアが低いフレームをスキップするように変更する：  

```python
# main.py 内のGPUマッチング前処理例
kld_scores = compute_kld_scores(batch_descriptors)  # 各フレームのKLDスコア計算
threshold = np.percentile(kld_scores, 30)           # 下位30%を除外
filtered_indices = [i for i, s in enumerate(kld_scores) if s > threshold]
filtered_descriptors = [batch_descriptors[i] for i in filtered_indices]

# GPUマッチング実行
frame_results, gpu_time = run_gpu_batch_matching(ctx, queue, kernel, filtered_descriptors, user_des_fp32)
```

この方法により、マッチング精度を維持しつつ、処理時間を削減することができる。
