
# GPU SIFT マッチング高速化の3つのアイデア

---

## ✅ アイデア1：`i-j` ペアを 1スレッドで処理

### ▶️ 内容
- `get_global_id(0)` を `i`、`get_global_id(1)` を `j` にして、**M×Nスレッド**を起動
- 各スレッドが `desc1[i]` と `desc2[j]` の距離を計算し、距離行列として出力
- 距離行列から最近傍（min1, min2）をホスト側で選択

### ✅ 利点
- 並列性を最大限活用（M×Nスレッド）
- 負荷分散が良好
- アクセスパターンが規則的で最適化しやすい

### ⚠️ 懸念点
- メモリ使用量が膨大（距離行列サイズ）
- min探索は別途必要（後処理の手間）
- メモリ帯域の圧迫が懸念

---

## ✅ アイデア2：`desc1` を ホスト側で分割して処理

### ▶️ 内容
- `desc1` を GPUコア数やメモリ制約に応じてバッチ分割
- 各チャンクに対して OpenCL カーネルを呼び出して距離計算を行う

### ✅ 利点
- 管理しやすい（バッチサイズで制御）
- GPUメモリの制限内で安定動作可能
- GPU使用率の調整がしやすい

### ⚠️ 懸念点
- ホスト側での分割・統合の手間
- バッチ間でのmin1, min2統合が必要
- カーネル呼び出しのオーバーヘッド

---

## ✅ アイデア3：行列演算として距離計算を構築

### ▶️ 内容
- `desc1` (M×128), `desc2` (N×128) を行列A, Bとみなす
- 次のように距離の2乗を計算：

  <p align="center">
  <strong>
  ‖a<sub>i</sub> − b<sub>j</sub>‖² = ‖a<sub>i</sub>‖² + ‖b<sub>j</sub>‖² − 2 a<sub>i</sub> · b<sub>j</sub>
  </strong>
  </p>

- 行列積やベクトル演算として計算（OpenCL BLAS的手法）

### ✅ 利点
- ベクトル命令やFMAの恩恵を受けやすい
- GPU最適化（行列乗算）は既に研究されている分野
- 大規模データに強い

### ⚠️ 懸念点
- 行列積最適化の難易度が高い（タイル分割、ローカルメモリなど）
- min探索処理が別途必要
- 転置やベクトル化の工夫が必要

---

## 🧠 全体比較まとめ

| 観点 | アイデア1<br>（i-j並列） | アイデア2<br>（分割バッチ） | アイデア3<br>（行列型） |
|------|----------------------|------------------------|----------------------|
| 並列性 | ◎（M×N） | △（Mのみ） | ◎（行列演算） |
| メモリ使用量 | ×（巨大距離行列） | 〇（分割で管理） | △（dot行列保存） |
| 実装の複雑さ | 中 | 低 | 高 |
| 処理速度の期待 | ◎ | 〇 | ◎ |
| 拡張性 | 高 | 高 | 高 |
